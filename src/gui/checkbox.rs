use crate::gui::Layoutable;
use crate::request::{
    query_by_ctrlid, CtrlId, EvtId, EvtUnpack, MessagePoolIn, MessagePoolOut, MessageProcessor,
    Unpack, QR,
};
use ggez::event::{EventHandler, MouseButton};
use ggez::graphics::{self, DrawMode, DrawParam, MeshBuilder, Rect};
use ggez::{Context, GameResult};
use std::collections::HashSet;

#[derive(Debug, Clone)]
pub enum Event {
    None,
    Init,
    Pressed,
    SetState(QR<bool, ()>),
    GetState(QR<(), bool>),
}

//
// To be generated by macro
//
impl EvtUnpack<(), bool> for Event {
    fn peek_response(&self, evt: EvtId<Event, (), bool>) -> Option<&bool> {
        let test = evt(QR::Response(bool::default()));
        match (self, test) {
            (Event::GetState(QR::Response(ref e)), Event::GetState(QR::Response(_))) => Some(e),
            _ => None,
        }
    }
    fn unpack_response(self, evt: EvtId<Event, (), bool>) -> Result<bool, Self>
    where
        Self: Sized,
    {
        let test = evt(QR::Response(bool::default()));
        match (self, test) {
            (Event::GetState(QR::Response(e)), Event::GetState(QR::Response(_))) => Ok(e),
            (m, _) => Err(m),
        }
    }
}

impl EvtUnpack<bool, ()> for Event {
    fn peek_response(&self, evt: EvtId<Event, bool, ()>) -> Option<&()> {
        let test = evt(QR::Response(<()>::default()));
        match (self, test) {
            (Event::SetState(QR::Response(ref e)), Event::SetState(QR::Response(_))) => Some(e),
            _ => None,
        }
    }
    fn unpack_response(self, evt: EvtId<Event, bool, ()>) -> Result<(), Self>
    where
        Self: Sized,
    {
        let test = evt(QR::Response(<()>::default()));
        match (self, test) {
            (Event::SetState(QR::Response(e)), Event::SetState(QR::Response(_))) => Ok(e),
            (m, _) => Err(m),
        }
    }
}

impl Default for Event {
    fn default() -> Event {
        Event::None
    }
}

pub struct Checkbox<MSG> {
    state: bool,
    touched: bool,
    notifications: Vec<MSG>,
    rect: Rect,
    ctrlid: CtrlId<MSG, Event>,
}

impl<MSG> Checkbox<MSG> {
    pub fn new(ctrl: fn(Event) -> MSG) -> Self {
        Self {
            state: false,
            touched: false,
            notifications: vec![ctrl(Event::Init)],
            rect: Rect::zero(),
            ctrlid: ctrl.into(),
        }
    }
}

impl<MSG> MessageProcessor<MSG> for Checkbox<MSG>
where
    MSG: Unpack<Event>,
{
    fn process(&mut self, src: &mut dyn MessagePoolIn<MSG>, dst: &mut dyn MessagePoolOut<MSG>) {
        for evt in query_by_ctrlid(src, self.ctrlid) {
            match evt {
                Event::SetState(QR::Query(v)) => {
                    self.state = v;
                    dst.push(self.ctrlid.tomsg(Event::SetState(QR::Response(()))))
                }
                Event::GetState(QR::Query(_)) => {
                    dst.push(self.ctrlid.tomsg(Event::GetState(QR::Response(self.state))))
                }
                _ => {}
            }
        }
        dst.append(&mut self.notifications);
    }
}

impl<MSG> EventHandler for Checkbox<MSG> {
    fn update(&mut self, _ctx: &mut Context) -> GameResult {
        Ok(())
    }

    fn draw(&mut self, ctx: &mut Context) -> GameResult {
        let mut rect = self.rect;
        let dsz = if self.touched { 10. } else { 5. };
        rect.x += dsz;
        rect.y += dsz;
        rect.w -= dsz * 2.;
        rect.h -= dsz * 2.;
        let mesh = MeshBuilder::new()
            .rectangle(
                if self.state {
                    DrawMode::fill()
                } else {
                    DrawMode::stroke(1.)
                },
                rect,
                graphics::WHITE,
            )
            .build(ctx)?;
        graphics::draw(ctx, &mesh, DrawParam::default())
    }

    fn mouse_button_down_event(&mut self, _ctx: &mut Context, button: MouseButton, x: f32, y: f32) {
        if button == MouseButton::Left && self.rect.contains([x, y]) {
            self.touched = true;
        }
    }

    fn mouse_button_up_event(&mut self, _ctx: &mut Context, _button: MouseButton, x: f32, y: f32) {
        if self.touched && self.rect.contains([x, y]) {
            self.state = !self.state;
            self.touched = false;
            self.notifications.push(self.ctrlid.tomsg(Event::Pressed));
        } else {
            self.touched = false;
        }
    }
}

impl<MSG> Layoutable for Checkbox<MSG> {
    fn set_rect(&mut self, x: f32, y: f32, w: f32, h: f32) {
        self.rect.x = x;
        self.rect.y = y;
        self.rect.w = w;
        self.rect.h = h;
    }
}
